clear
clc
addpath('FORCES_client');

% Example script for getting started with FORCES NLP solver.
%
%--------------------------------------------------------------------------
% NOTE: This example shows how to define a nonlinear programming problem,
% where all derivative information is automatically generated by
% using the AD tool CasADi.
% 
% You may want to directly pass C functions to FORCES, for example when you 
% are using other AD tools, or have custom C functions for derivate 
% evaluation etc. See the example file "NLPexample_ownFevals.m" for how to
% pass custom C functions to FORCES.
%--------------------------------------------------------------------------
%
% This example solves an optimization problem for a car with the simple
% continuous-time, nonlinear dynamics
%
%    dx/dt = v*cos(theta)
%    dy/dt = v*sin(theta)
%    dv/dt = F/m
%    dtheta/dt = v*s/L
%
% where x,y are the position, v the velocity in heading angle theta of the
% car. The inputs are F (accelerating force) and steering s.
%
% The car starts from standstill with a certain heading angle, and the
% optimization problem is to maximize progress in y direction while staying
% inside a non-convex feasible region.
%
% Quadratic costs for the acceleration force and steering are added to the
% objective to avoid excessive maneouvers.
%
% There are bounds on all variables.
%
% Variables are collected stage-wise into z = [F s x y v theta].
%
% See also FORCES_NLP
%
% (c) embotech GmbH, Zurich, Switzerland, 2013-16.

clear; clc; close all;
import casadi.*;

rad2deg = @(x) x/pi*180;
deg2rad = @(x) x/180*pi;

%% Problem dimensions
model.N     = 50;        % horizon length
model.nvar  = 6;          % number of variables
model.neq   = 4;          % number of equality constraints
model.nh    = 2;          % number of inequality constraint functions

%% Objective function (Ex. 3.1)
% In this example, we want to maximize position in y direction,
% with some penalties on the inputs F and s:

costs = [100,1,1];

xf = -0.2;
yf =  2.8;
% cost function is the absolute distance to the goal,
% x and y are equally weighted
% TODO: add velocity term and input costs
model.objective = @(z) costs(1)*((z(3)-xf)^2+(z(4)-yf)^2) + costs(2)*z(1)^2 + costs(3)*z(2)^2; 

% You can use standard Matlab handles to define these functions, i.e. you
% could also have this in a separate file. We use anonymous handles here
% only for convenience.

%% Dynamics, i.e. equality constraints (Ex. 3.2) 
% We use an explicit RK4 integrator here to discretize continuous dynamics:
m=0.9; L=0.12; % physical constants of the model
integrator_stepsize = 0.1;
continuous_dynamics = @(x,u) [x(3)*cos(x(4));  % v*cos(theta)
                              x(3)*sin(x(4));  % v*sin(theta)
                              u(1)/m;          % F/m
                              x(3)*u(2)/L];    % v*s/L
model.eq = @(z) RK4( z(3:6), z(1:2), continuous_dynamics, integrator_stepsize);

% Indices on LHS of dynamical constraint - for efficiency reasons, make
% sure the matrix E has structure [0 I] where I is the identity matrix.
model.E = [zeros(4,2), eye(4)];

%% Inequality constraints (Ex. 3.3)
% upper/lower variable bounds lb <= z <= ub
%            inputs    |        states
%             F     , s     , x     ,y      ,v      ,theta
model.lb = [ -5     ,-1     ,-3     ,0      ,0      ,-pi];
model.ub = [  5     , 1     , 0     ,3      ,2      ,pi];

% General (differentiable) nonlinear inequalities hl <= h(z) <= hu
a1 = -0.8;    b1 = 2.5;   p1 = 2;
a2 = -1.5;  b2 = 1;     p2 = 20;
model.ineq = @(z) [ (z(3) - a1)^p1 + (z(4)- b1)^p1
                    (z(3) - a2)^p2 + (z(4)- b2)^p2 ];
% Upper/lower bounds for inequalities
model.hl = [ 0.05, 1 ]';
model.hu = [ +inf, +inf ]';

%% Initial and final conditions (Ex. 3.4)

% Initial condition on vehicle states
model.xinit = [-2.7, 0.5, 0, 3/4*pi].';
model.xinitidx = 3:6; % use this to specify on which variables initial conditions are imposed

% Final condition on vehicle velocity and heading angle
model.xfinal = [0,0].';
model.xfinalidx = 5:6; % use this to specify on which variables final conditions are imposed


%% Define solver options
codeoptions = getOptions('FORCESNLPsolver');
% codeoptions.server = 'http://embotech-server2.ee.ethz.ch:8114/v1.5.beta'; % change this to your server or leave empty for using the standard embotech server
codeoptions.maxit = 2e3;    % Maximum number of iterations
codeoptions.printlevel = 2; % Use printlevel = 2 to print progress (but not for timings)
codeoptions.optlevel = 0; % 2: optimize for speed
codeoptions.cleanup = 0;
% codeoptions.nlp.lightCasadi = 1;

%% Generate forces solver
FORCES_NLP(model, codeoptions);

%% Call solver
% Set initial guess to start solver from:
x0i=model.lb+(model.ub-model.lb)/2;
x0=repmat(x0i',model.N,1);
problem.x0=x0; 

% Set initial and final conditions. This is usually changing from problem
% instance to problem instance:
problem.xinit = model.xinit;
problem.xfinal = model.xfinal;
problem.all_parameters = [5; 10];

% Time to solve the NLP!
[output,exitflag,info] = FORCESNLPsolver(problem);

% Make sure the solver has exited properly. 
assert(exitflag == 1,'Some problem in FORCES solver');
fprintf('\nFORCES took %d iterations and %f seconds to solve the problem.\n',info.it,info.solvetime);

%% Plot custom constraints
close all
% square
a  = -1.5;
b  = 1;
p  = 20;% 20 norm creates a rounded square, p-> infinity -> perfect square
x  = -3:0.01:0;
y1 = b+(1-(x-a).^p).^(1/p);
y2 = b-(1-(x-a).^p).^(1/p);
slice = real(y1) == y1;
plot(x(slice),y1(slice),'-r','LineWidth',2); hold on;
plot(x(slice),y2(slice),'-r','LineWidth',2);
xlim([-3,0]);
ylim([0,3]);

% Circle
a  = -0.8;
b  = 2.5;
p  = 2;
r  = 0.05^0.5;
y1 = b+(r^2-(x-a).^p).^(1/p);
y2 = b-(r^2-(x-a).^p).^(1/p);
slice = real(y1) == y1;


rectangle('Position',[a-r, b-r, 2*r, 2*r],'Curvature',[1 1],'EdgeColor','r','LineStyle','-','LineWidth',2);
axis square;
title('position'); xlim([-3 0]); ylim([0 3]); xlabel('x position'); ylabel('y position');


% plot(x(slice),y1(slice),'-r'); hold on;
% plot(x(slice),y2(slice),'-r');

print -depsc2 'figures/world.eps'

%% Plot results
TEMP = zeros(model.nvar,model.N);
for i=1:model.N
    try
        TEMP(:,i) = output.(['x',sprintf('%02d',i)]);
    catch
        TEMP(:,i) = output.(['x',sprintf('%03d',i)]);
    end    
end
U = TEMP(1:2,:);
X = TEMP(3:6,:);

% plot trajectory
plot(X(1,:),X(2,:),'b-','LineWidth',3); hold on; 

plot(model.xinit(1),model.xinit(2),'bx','LineWidth',3); 
plot(X(1,end),X(2,end),'rx','LineWidth',3); 

print -depsc2 'figures/world_res.eps'

% plot heading angle and velocity variables
figure(2); clf;
subplot(2,1,1); plot(X(3,:)); grid on; title('velocity'); hold on; 
plot([1 model.N], [model.ub(5) model.ub(5)]', 'r:');
plot([1 model.N], [model.lb(5) model.lb(5)]', 'r:');
subplot(2,1,2); plot(rad2deg(X(4,:))); grid on; title('heading angle'); ylim([0, 180]); hold on; 
plot([1 model.N], rad2deg([model.ub(6) model.ub(6)])', 'r:');
plot([1 model.N], rad2deg([model.lb(6) model.lb(6)])', 'r:');

% plot inputs
figure(3); clf;
subplot(2,1,1); stairs(U(1,:)); grid on; title('acceleration force'); hold on; 
plot([1 model.N], [model.ub(1) model.ub(1)]', 'r:');
plot([1 model.N], [model.lb(1) model.lb(1)]', 'r:');
subplot(2,1,2); stairs(U(2,:)); grid on; title('delta steering'); hold on; 
plot([1 model.N], [model.ub(2) model.ub(2)]', 'r:');
plot([1 model.N], [model.lb(2) model.lb(2)]', 'r:');
